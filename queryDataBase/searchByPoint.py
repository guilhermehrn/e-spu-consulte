# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SearchByPoint
                                 A QGIS plugin
 Consulta Sobreposição com áreas do Governo Federal do Brasil
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-11-12
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Guilherme Henrique
        email                : guilherme.nascimento@planejamento.gov.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5 import uic
from PyQt5 import QtWidgets
import psycopg2
import urllib.request
import urllib.parse
import json
from collections import namedtuple

from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import QMessageBox, QDialog
from qgis.PyQt.QtCore import pyqtSlot, QUrl

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'searchByPoint.ui'))

from .resultQuery import ResultQuery
from ..configuration.configurationDialog import ConfigurationDialog
from ..dbTools.dbTools import DbTools

class SearchByPoint(QDialog, FORM_CLASS):

    def __init__(self, iface):
        """Constructor."""

        QDialog.__init__(self)
        self.setupUi(self)
        self.iface = iface

        #super(EspuConsulteDialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        self.nameConect = ConfigurationDialog.getLastNameConnection(self)
        (self.host,self.port, self.db, self.user, self.password) = ConfigurationDialog.getServerConfiguration(self, self.nameConect)
        self.iniciar.clicked.connect(self.consultDatabase)
        self.ignoreTable = ["unidade_federacao", "municipio"]

    def trasformSelctLayerToWkb(self):
        """TODO"""
        currentLayer = self.iface.mapCanvas().currentLayer()

        if currentLayer:

            selectedFeatures = len(currentLayer.selectedFeatures())

            if selectedFeatures == 1:

                selectedFeature = currentLayer.selectedFeatures()[0]
                d = selectedFeature.geometry().asWkt()
                print (d)

            else:
                QMessageBox.warning(self.iface.mainWindow(), self.tr("Warning!"), self.tr("One and only one feature must be selected to perform the calculations."))
        else:
            QMessageBox.warning(self.iface.mainWindow(), self.tr("Warning!"), self.tr("Please, open a layer and select a line or polygon feature."))


    def queryFromVectorObject(self):
        self.trasformSelctLayerToWkb()

        try:

            print (self.nameConect)
            print (self.host,self.port, self.db, self.user, self.password)
            conn = psycopg2.connect(" dbname=" + self.db + " user=" + self.user + " host=" + self.host + " password=" + self.password )

            if conn:
                print ("FOI!")

        except:
            print ("I am unable to connect to the database")

        sql = "SELECT * from"

    def geocodingGoogle(self):
        address = self.address.text()
        neighborhood = self.neighborhood.text()
        city = self.city.text()
        postalCode = self.postalCode.text()
        state = self.state.currentText()

        key = ""

        addr = address + "," + neighborhood + "," + city + "," + postalCode + "," + state
        addr = urllib.parse.quote(addr)
        url = "https://maps.googleapis.com/maps/api/geocode/json?address=" + addr + "&key=" + key

        #url = "https://maps.googleapis.com/maps/api/geocode/json?address=" + address + "," + neighborhood + "," + city.decode('utf8') + "," + postalCode + "," + state + "&key="+key
        print (url)

        contents = urllib.request.urlopen(url).read()
        print (contents)

        return contents


    def consultDatabase (self):
        data = self.geocodingGoogle()
        resultGeo = json.loads(data)['results']
        location =  resultGeo[0]['geometry']['location']
        datunGoogle = '4326'
        raio = self.radius.value()
        count = 0
        addrFormat = resultGeo[0]["formatted_address"]
        results={}

        dbt = DbTools()

        tablesGeo = dbt.getTablesGeo(schemaName='public') #depois mudar para view 'faixa_seguranca'
        tablesGeoColumns = dbt.getTablesCollumnsAll(tablesGeo,'public')

        point = self.createPointLayer((location["lng"], location["lat"]), datunGoogle)

        for i in range(0,len(self.ignoreTable)):
            tablesGeo.remove(self.ignoreTable[i])

        ufIntecectList = dbt.calculateIntersectByPoint((location["lng"], location["lat"]), "unidade_federacao", datunGoogle, raio)
        municipioInterctList = dbt.calculateIntersectByPoint((location["lng"], location["lat"]), "municipio", datunGoogle, raio)
        for table in tablesGeo:
            count =count+1
            #self.labelStatusProgress.setText('Verificando em: ' + table )
            result = dbt.calculateIntersectByPoint((location["lng"], location["lat"]), table, datunGoogle, raio)

            if len(result)!=0:
                results.update({table:result})
            result = []

            #acumuladoProgresso= acumuladoProgresso+ porcentProgress
            #self.progressBar.setValue(acumuladoProgresso)

            #if count == int(len(tablesGeo)):
            #    self.progressBar.setValue(100)
            #    self.labelStatusProgress.setText('Verificação Finalizada!' )



        if results:
            self.generatorReport(results, tablesGeoColumns, ufIntecectList, municipioInterctList, point, addrFormat)

        else:
            QMessageBox.warning(self.iface.mainWindow(), self.tr("Informação!"), self.tr("Areas não encontradas"))



        #dbt.calculateIntersectByPoint((location["lng"], location["lat"]), 'area_especial', datunGoogle, raio)

    def showResult(self):
        d=ResultQuery(self.iface)
        d.exec_()

    def createPointLayer(self, pointCord, sridInit):
        dbt = DbTools()
        return dbt.createPoint(pointCord, sridInit)


    def generatorReport(self, results, tablesGeoColumns, ufIntecectList, municipioInterctList, point, attr):

        """Generates a summary report of the result of the query"""

        print ("Listas", results.keys())
        d=ResultQuery(self.iface, results, tablesGeoColumns, ufIntecectList, municipioInterctList)
        d.fillTable()
        d.generatePointLayer(point, attr)
        d.exec_()


#manipulando a classe geometry e transformando em wkt e wkb.
#https://github.com/skeenp/QGIS3-getWKT/blob/master/getwkt3.py
#https://qgis.org/api/classQgsGeometry.html

#tutorial de postgres no python
#https://pynative.com/python-postgresql-tutorial/

#return fk table do postgres
#https://dba.stackexchange.com/questions/36979/retrieving-all-pk-and-fk
#https://stackoverflow.com/questions/1152260/postgres-sql-to-list-table-foreign-keys
